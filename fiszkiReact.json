[{"page_number": 0, "text": "React\nCzym jest React?\n01 "}, {"page_number": 1, "text": "React to otwarta biblioteka JavaScript stworzona przez Face-\nbook w 2011 roku w celu usprawnienia tworzenia zaawanso -\nwanych aplikacji internetowych i mobilnych - w szczeg\u00f3lno\u015bci \nSPA - Single Page Applications . \nG\u0142\u00f3wny nacisk jest po\u0142o\u017cony na wydajno\u015b\u0107 i szybko\u015b\u0107 rendero -\nwania komponent\u00f3w.\nDo najwa\u017cniejszych cech Reacta nale\u017c\u0105:\n\u2022 Wykorzystanie Virtual DOM zamiast prawdziwego DOM \nw celu manipulowania widokiem,\n\u2022 Jednokierunkowy  przep\u0142yw danych w aplikacji,\n\u2022 Wsparcie dla SSR (ang. Server-Side Rendering),\n\u2022 Tworzenie re-u\u017cywanych komponent\u00f3w,\n\u2022 Wykorzystanie JSX  do projektowania komponent\u00f3w."}, {"page_number": 2, "text": "React\n02 Jakie s\u0105 zalety \ni wady Reacta?"}, {"page_number": 3, "text": "Do korzy\u015bci korzystania z Reacta  nale\u017cy:\n\u2022 Lepsza wydajno\u015b\u0107 dzia\u0142ania aplikacji,\n\u2022 Czytelny i \u0142atwy w utrzymaniu kod,\n\u2022 Proste i sp\u00f3jne komponenty dzi\u0119ki zastosowaniu JSX,\n\u2022 Du\u017ca swoboda w doborze dodatkowych narz\u0119dzi, \nbibliotek oraz technik programowania,\n\u2022 Szybkie i czytelne testy.\nDo wad mo\u017cna zaliczy\u0107:\n\u2022 Trudno\u015b\u0107 w zachowaniu sp\u00f3jnych standard\u00f3w pisania kodu pomi\u0119dzy zespo\u0142ami, wynikaj\u0105ca z du\u017cej swobody wyboru bibliotek i technik programowania,\n\u2022 Rozbudowany ekosystem Reacta utrudniaj\u0105cy prac\u0119 mniej do\u015bwiadczonym programistom - ka\u017cdy problem mo\u017cna rozwi\u0105za\u0107 z wykorzystaniem r\u00f3\u017cnych bibliotek."}, {"page_number": 4, "text": "React\n03 Co odr\u00f3\u017cnia React \nod Angular?"}, {"page_number": 5, "text": "React Angular\nBiblioteka zapewniaj\u0105ca \nobs\u0142ug\u0119 View w klasycznym modelu MVCFramework zapewniaj\u0105cy pe\u0142ne wsparcie dla MVC\nJednokierunkowy przep\u0142yw danychDwukierunkowy przep\u0142yw danych\nWykorzystuje Virtual DOM Wykorzystuje prawdziwy DOM\nWsparcie dla Server Side \nRenderingServer Side Rendering jedynie poprzez u\u017cycie Angular Universal\nTworzenie widok\u00f3w za pomoc\u0105 JSXTworzenie widok\u00f3w na pod -\nstawie szablon\u00f3w HTML"}, {"page_number": 6, "text": "React\n04 Czym jest  \nVirtual DOM?"}, {"page_number": 7, "text": "Virtual DOM  to koncepcja programistyczna, w kt\u00f3rej wirtualna \nreprezentacja interfejsu u\u017cytkownika jest przechowywana w \npami\u0119ci i synchronizowana z prawdziwym modelem DOM \nprzez bibliotek\u0119 React. Proces ten nazywa si\u0119 rekoncyliacj\u0105  \n(ang. reconciliation).\nWykorzystanie wirtualnego modelu DOM tworzy przejrzysty \ninterfejs pozwalaj\u0105cy programistom na pomini\u0119cie lub przy -\nspieszenie kosztownych operacji. Dodatkowo React ukrywa \npod warstw\u0105 abstrakcji  manipulacj\u0119 atrybutami, obs\u0142ug\u0119 \nzdarze\u0144 i r\u0119czn\u0105 aktualizacj\u0119 modelu DOM.\nZmiany dokonane na Virtual DOM s\u0105 synchronizowane  \nw wi\u0119kszych paczkach a nie pojedynczo, co znacznie przyspie -\nsza aktualizacj\u0119 widoku."}, {"page_number": 8, "text": "React\n05 Jaka jest r\u00f3\u017cnica \nmi\u0119dzy DOM  a Virtual DOM?"}, {"page_number": 9, "text": "DOM Virtual DOM\nPowolna aktualizacja modelu Bardzo szybka aktualizacja\nZmiany w modelu DOM s\u0105 \nbardzo kosztowne Modyfikacje Virtual DOM s\u0105 tanie a rzeczywista syn -\nchronizacja z prawdziwym \nmodelem DOM nast\u0119puje w fazie rekoncyliacji\nMo\u017ce aktualizowa\u0107 HTML bezpo\u015brednioNie mo\u017ce aktualizowa\u0107 HTML bezpo\u015brednio\nDu\u017ce zu\u017cycie pami\u0119ci i mo\u017c -\nliwe trudne do zdiagnozo -\nwania wyciekiOgraniczone zu\u017cycie pami\u0119ci"}, {"page_number": 10, "text": "React\n06 Czym jest JSX?"}, {"page_number": 11, "text": "JSX to przypominaj\u0105ce XML rozszerzenie j\u0119zyka JavaScript, za \npomoc\u0105 kt\u00f3rego mo\u017cna \u0142\u0105czy\u0107 kod JavaScript z HTML w jed -\nnym pliku. Dzi\u0119ki temu zarz\u0105dzanie i utrzymywanie kodu jest \nznacznie \u0142atwiejsze. \nJSX mo\u017ce przypomina\u0107 j\u0119zyk oparty o szablony, jednak\u017ce daje \non do dyspozycji pe\u0142ni\u0119 mo\u017cliwo\u015bci JavaScriptu. \nconst name = 'Bob';\nconst element  = <h1>Hello, {name}</h1>;\nReactDOM. render(\n  element ,\n  document .getElementById ('root')\n);"}, {"page_number": 12, "text": "React\n07 Do czego s\u0142u\u017c\u0105 \nprops?"}, {"page_number": 13, "text": "Koncepcyjnie, komponenty s\u0105 jak funkcje w JavaScript. \nPrzyjmuj\u0105 parametry (nazywane w\u0142a\u015bciwo\u015bciami - props) na \nwej\u015bciu i zwracaj\u0105 komponenty React opisuj\u0105ce, co powinno si\u0119 pojawi\u0107 na ekranie.\nMog\u0105 to by\u0107 zar\u00f3wno pojedyncze warto\u015bci, jak i ca\u0142e obiekty.Props wykorzystuje si\u0119 do:\n\u2022 Do przekazania danych do komponentu,\n\u2022 Wywo\u0142ania zmiany stanu komponentu,\n\u2022 Tworzenia widoku wewn\u0105trz metody render() .\nfunction  Welcome (props) {\n    return <h1>Hello, {props.name}</h1>;\n}"}, {"page_number": 14, "text": "React\n08 Jaka jest r\u00f3\u017cnica \npomi\u0119dzy state i props?"}, {"page_number": 15, "text": "Zar\u00f3wno state, jak i props to obiekty JavaScript przechowuj\u0105 -\nce informacje, na podstawie kt\u00f3rych nast\u0119puje renderowanie. \nProps s\u0105 przekazywane do komponentu z zewn\u0105trz i stanowi\u0105 \njego konfiguracj\u0119. W podobny spos\u00f3b parametry s\u0105 przekazy -\nwane do wywo\u0142ywanej funkcji w JavaScript. \nInnymi s\u0142owy, props opisuj\u0105 w jaki spos\u00f3b komponenty ko-\nmunikuj\u0105 si\u0119 mi\u0119dzy sob\u0105. Komponent nie mo\u017ce modyfikowa\u0107 obiektu props.\nState nie jest przekazywany do komponentu z zewn\u0105trz, ale \njest utrzymywany i zarz\u0105dzany przez komponent w spos\u00f3b po -\ndobny do tego, jak zmienne lokalne s\u0105 obs\u0142ugiwane wewn\u0105trz cia\u0142a funkcji. Komponent podczas tworzenia otrzymuje stan \ndomy\u015blny, kt\u00f3ry nast\u0119pnie mo\u017ce by\u0107 wielokrotnie modyfiko -\nwany w trakcie \u017cycia komponentu."}, {"page_number": 16, "text": "React\n09 Na czym polega \nprop drilling ?"}, {"page_number": 17, "text": "Prop drilling wyst\u0119puje, gdy chcemy przekaza\u0107 dane z kom -\nponentu rodzica do komponentu wyst\u0119puj\u0105cego g\u0142\u0119biej \nw drzewie komponent\u00f3w. \nPrzekazuj\u0105c informacje przez kolejne poziomy komponent\u00f3w \nuzale\u017cniamy te komponenty od danych, kt\u00f3rych nie powinny by\u0107 \u015bwiadome. Utrudnia to ponowne wykorzystanie kodu.\nAby unikn\u0105\u0107 problem\u00f3w zwi\u0105zanych z prop drilling mo\u017cna \nwykorzysta\u0107 React Context . \nKomponent Provider  jest wtedy odpowiedzialny za dostar -\nczenie danych, kt\u00f3re mog\u0105 by\u0107 odczytane przez zagnie\u017cd\u017cone \nkomponenty poprzez hook useContext()  albo komponent \nConsumer .\nDrugim rozwi\u0105zaniem jest wykorzystanie mechanizm\u00f3w zarz\u0105 -\ndzania stanem, np. Redux."}, {"page_number": 18, "text": "React\n10 W jaki spos\u00f3b \nwymusi\u0107 typ props?"}, {"page_number": 19, "text": "Aby sprawdzi\u0107 typ w\u0142a\u015bciwo\u015bci przekazanych do komponentu \nnale\u017cy skorzysta\u0107 z biblioteki propTypes, kt\u00f3ra zawiera walida -\ntory do sprawdzania typu i poprawno\u015bci danych wej\u015bciowych. \nKiedy warto\u015b\u0107 przekazanych props b\u0119dzie nieprawid\u0142owego \ntypu, zostanie wy\u015bwietlone ostrze\u017cenie w konsoli przegl\u0105darki.Ze wzgl\u0119d\u00f3w wydajno\u015bciowych, propTypes s\u0105 sprawdzane \ntylko w trybie deweloperskim.\nimport PropTypes from 'prop-types ';\nclass Greeting  extends  React.Component  { \u2026 }\nGreeting .propTypes = {\n  name: PropTypes.string\n};"}, {"page_number": 20, "text": "React\n11 Jak sprawdzi\u0107 czy \nw props przekazano jeden child?"}, {"page_number": 21, "text": "Aby sprawdzi\u0107 czy do komponentu przekazano tylko jeden \nchild komponent (jednego potomka) nale\u017cy skorzysta\u0107 z wali -\ndatora propTypes.element , przyk\u0142adowo:\nimport PropTypes from 'prop-types ';\nclass Sidebar  extends  React.Component  {\n    render() {\n        const children  = this.props.children;\n        return (\n            < div>\n                {children }\n            </ div>\n        );\n    }}\nSidebar.propTypes = {\n    children : PropTypes. element.isRequired\n};"}, {"page_number": 22, "text": "React\n12 Do czego s\u0142u\u017cy \nReact Context?"}, {"page_number": 23, "text": "React Context s\u0142u\u017cy do przekazywania danych wewn\u0105trz drze -\nwa komponent\u00f3w bez konieczno\u015bci przekazywania ich przez \nw\u0142a\u015bciwo\u015bci ka\u017cdego komponentu po drodze. Unikamy w ten spos\u00f3b tzw. prop drilling .\nKonteksty zaprojektowano do wsp\u00f3\u0142dzielenia danych, kt\u00f3re \nmo\u017cna uzna\u0107 za globalne dla ca\u0142ego drzewa komponent\u00f3w, \nconst ThemeContext  = React. createContext ('dracula ');\n \n// render parent komponentu\n<ThemeContext.Provider  value=\"solar\">\n    <Toolbar />\n</ThemeContext.Provider >\nclass Toolbar  extends  React.Component  {\n    static contextType = ThemeContext ;\n    render() {\n        return <Button  theme={this.context } />;\n    }}"}, {"page_number": 24, "text": "React\n13 Czym jest \nReactDOM?"}, {"page_number": 25, "text": "ReactDOM jest elementem \u0142\u0105cz\u0105cym React z modelem DOM. \nUdost\u0119pnia metody specyficzne dla DOM, kt\u00f3re mog\u0105 by\u0107 \nu\u017cywane na najwy\u017cszym poziomie aplikacji.\nPodstawowa biblioteka react  udost\u0119pnia funkcjonalno\u015bci, \nkt\u00f3re s\u0105 wsp\u00f3lne niezale\u017cnie tego, czy tworzymy aplikacj\u0119 \nwebow\u0105 czy mobiln\u0105. \nPrzyk\u0142adowo s\u0105 to: funkcja React.createElement() , klasy \nReact.Component , React.Children  oraz wiele innych \nprzydatnych konstrukcji wykorzystywanych do budowania \nkomponent\u00f3w.\nBiblioteka react-dom  zawiera z kolei ReactDOM.render()  \noraz kod potrzebny do obs\u0142ugi Server-side Rendering."}, {"page_number": 26, "text": "React\n14 Do czego s\u0142u\u017c\u0105 \nhooki?"}, {"page_number": 27, "text": "Hooki s\u0105 to funkcj\u0119, kt\u00f3re pozwalaj\u0105 u\u017cywa\u0107 stanu i innych \nfunkcjonalno\u015bci Reacta bez u\u017cycia klas. Przenosz\u0105 mocne stro -\nny komponent\u00f3w opartych na klasach (np. zarz\u0105dzanie stanem \ni cyklem \u017cycia komponentu) na komponenty funkcyjne :\nimport React, { useState } from 'react';\nexport function  CounterHook () {\n  const [count, setCount ] = useState (0);\n  return  (\n    <div>\n      <p>You clicked {count} times!</ p>\n      <button onClick ={() => setCount (count + 1)}>\n        Click me!\n      </ button>\n    </div>\n  );}"}, {"page_number": 28, "text": "React\n15 Jakie s\u0105 korzy\u015bci \nkorzystania z hook\u00f3w?"}, {"page_number": 29, "text": "Hooki  maj\u0105 wiele zalet zwi\u0105zanych z organizacj\u0105 kodu oraz \nwykorzystaniem komponent\u00f3w funkcyjnych:\n\u2022 Oddzielaj\u0105 logik\u0119 zwi\u0105zan\u0105 ze stanem od komponentu,\n\u2022 U\u0142atwiaj\u0105 ponowne wykorzystanie kodu bez konieczno -\n\u015bci zmiany hierarchii komponent\u00f3w,\n\u2022 Przyspieszaj\u0105 testowanie, poniewa\u017c nie s\u0105 wymagane \ndodatkowe zale\u017cno\u015bci do komponent\u00f3w,\n\u2022 Pozwalaj\u0105 podzieli\u0107 komponent na mniejsze funkcje, ba -\nzuj\u0105c na ich odpowiedzialno\u015bci (np. tworzenie subskryp -\ncji czy pobieranie danych), zamiast wymusza\u0107 sztuczny podzia\u0142 zwi\u0105zany z metodami cyklu \u017cycia,\n\u2022 Pozwalaj\u0105 na korzystanie z wi\u0119kszej liczby funkcjonalno -\n\u015bci Reacta bez u\u017cycia klas,\n\u2022 S\u0105 kompatybilne wstecz i dzia\u0142aj\u0105 r\u00f3wnolegle z istniej\u0105 -\ncym kodem, co u\u0142atwia ich wdra\u017canie"}, {"page_number": 30, "text": "React\n16 Jak pomin\u0105\u0107 \nwywo\u0142anie useEffect?"}, {"page_number": 31, "text": "Domy\u015blnie hook useEffect()  (oraz sprz\u0105tanie po nim) jest \nwywo\u0142ywany przy ka\u017cdym renderowaniu, jednak w niekt\u00f3rych \nprzypadkach mo\u017ce to spowodowa\u0107 problemy z wydajno\u015bci\u0105.\nW komponentach klasowych mo\u017cemy rozwi\u0105za\u0107 problem \nzbyt cz\u0119stego renderowania por\u00f3wnuj\u0105c warto\u015bci prevProps  \ni prevState  wewn\u0105trz metody componentDidUpdate .\nW komponentach funkcyjnych wykorzystuj\u0105cych hooki, mo\u017cna \nnatomiast  rozwi\u0105za\u0107 ten problem przez pomini\u0119cie wywo\u0142ania \nefektu, je\u015bli pewne warto\u015bci nie zmieni\u0142y si\u0119 mi\u0119dzy kolejnymi renderowaniami. Aby to zrobi\u0107, nale\u017cy przekaza\u0107 tablic\u0119 jako \nopcjonalny drugi argument useEffect() , na przyk\u0142ad:\nuseEffect (() => {\n    document .title = `Clicked ${count} times!`\n}, [count]);"}, {"page_number": 32, "text": "React\n17 Jak wywo\u0142a\u0107 hook \nuseEffect tylko raz?"}, {"page_number": 33, "text": "Aby wywo\u0142a\u0107 hook useEffect()  tylko jeden raz podczas mon-\ntowania komponentu, nale\u017cy przekaza\u0107 pust\u0105 tablic\u0119 [] jako \ndrugi argument efektu. \nW ten spos\u00f3b React wie, \u017ce efekt nie zale\u017cy od warto\u015bci \nzewn\u0119trznych, wi\u0119c nie musi by\u0107 ponownie uruchamiany pod -\nczas kolejnego renderowania. Po przekazaniu pustej tablicy \n[], w\u0142a\u015bciwo\u015bci i stan wewn\u0105trz efektu zawsze przyjm\u0105 swoje \npocz\u0105tkowe warto\u015bci.\nuseEffect (async () => {\n  const result = await  axios(\n    'https://fiszkijs.pl/api/v1/questions ',\n  );\n  setQuestions (result.data);\n}, []);"}, {"page_number": 34, "text": "React\n18 Jak memoizowa\u0107 \nobliczenia za pomoc hook\u00f3w?"}, {"page_number": 35, "text": "Memoizacj\u0119  mo\u017cna osi\u0105gn\u0105\u0107 zapami\u0119tuj\u0105c wynik opera -\ncji pomi\u0119dzy kolejnymi renderowaniami za pomoc\u0105 hooka \nuseMemo() . \nMo\u017cna w ten spos\u00f3b przechowywa\u0107 wyniki ci\u0119\u017ckich oblicze\u0144 \nlub kosztownego renderowania child komponent\u00f3w:\nconst counter  = useMemo (\n  () => <Counter  count={total} />, [ total]\n);\nPowy\u017cszy kod sprawia, \u017ce komponent Counter  b\u0119dzie ponow -\nnie renderowany tylko wtedy, gdy zmieni si\u0119 warto\u015b\u0107 total . \nJe\u015bli jednak zale\u017cno\u015b\u0107 [total]  nie zmieni\u0142a si\u0119 od ostatniego \nrazu, useMemo()  pominie kolejne wywo\u0142anie funkcji i zamiast \ntego zwr\u00f3ci poprzedni wynik."}, {"page_number": 36, "text": "React\n19 Jak za pomoc\u0105 \nhook\u00f3w tworzy\u0107 \"ci\u0119\u017ckie\" obiekty?"}, {"page_number": 37, "text": "\"Ci\u0119\u017ckie\" obiekty mo\u017cna tworzy\u0107 w leniwy spos\u00f3b  (lazy \nloading), lub wykorzysta\u0107 do tego memoizacj\u0119.\nMemoizacja  realizowana za pomoc\u0105 useMemo()  pozwala na \nprzechowywanie wynik\u00f3w kosztownych oblicze\u0144, pod warun -\nkiem, \u017ce ich zale\u017cno\u015bci s\u0105 takie same. Jednak useMemo()  nie \ngwarantuje , \u017ce obliczenia te zostan\u0105 wykonane tylko raz. \nTworzenie obiekt\u00f3w w spos\u00f3b leniwy mo\u017cna zrealizowa\u0107 za \npomoc\u0105 useState()  oraz funkcji inicjalizuj\u0105cej , co gwarantu -\nje, \u017ce React wywo\u0142a j\u0105 tylko przy pierwszym renderowaniu:\nfunction  DataGrid (props) {\n    const [data, setData ] = useState (\n        () => loadGridData (props.source)\n    );\n    // ...\n}"}, {"page_number": 38, "text": "React\n20 Do czego s\u0142u\u017cy \nfunkcja render?"}, {"page_number": 39, "text": "Funkcja ReactDOM.render()  renderuje element do drzewa \nDOM i umieszcza go w kontenerze podanym jako argument. \nZwraca referencj\u0119 do komponentu (lub null dla komponent\u00f3w bezstanowych).\nW przypadku renderowania wi\u0119cej ni\u017c jednego elementu, mu -\nsz\u0105 by\u0107 one obj\u0119te wsp\u00f3lnym tagiem, np. <form>  lub <div> .\nJe\u015bli element by\u0142 wcze\u015bniej renderowany, zostanie automatycz -\nnie zaktualizowany  przez Reacta, kt\u00f3ry odpowiednio zmody -\nfikuje DOM, aby odzwierciedli\u0107 najnowsz\u0105 wersj\u0119 komponentu.\nReactDOM. render(\n    < React.StrictMode >\n        < App />\n    </ React.StrictMode >,\n    document .getElementById ('root')\n);"}, {"page_number": 40, "text": "React\n21 Co r\u00f3\u017cni \nkomponenty funkcyjne i klasowe?"}, {"page_number": 41, "text": "Komponenty klasowe pozwalaj\u0105 na korzystanie z lokalnego \nstanu komponentu oraz metod cyklu \u017cycia komponentu. Dzie -\ndzicz\u0105 je z klasy React.Component , kt\u00f3r\u0105 musz\u0105 rozszerza\u0107. \nKomponenty funkcyjne  nie posiadaj\u0105 swojego wewn\u0119trznego \nstanu oraz nie mo\u017cna w nich korzysta\u0107 z metod cyklu \u017cycia komponentu. \nS\u0105 to zwyk\u0142e funkcje JavaScript, kt\u00f3re otrzymuj\u0105 obiekt props  \njako parametr wej\u015bciowy i zwracaj\u0105 nowy element. W zwi\u0105zku \nz tym nie mog\u0105 przechowywa\u0107 swojego wewn\u0119trznego stanu. \nAby korzysta\u0107 z obiektu stanu w komponentach funkcyjnych \nmo\u017cna a) skorzysta\u0107 z hook\u00f3w, b) zmieni\u0107 je na komponenty klasowe, lub c) przekaza\u0107 stan do obiektu rodzica i stamt\u0105d \ntworzy\u0107 komponenty, przekazuj\u0105c stan jako props ."}, {"page_number": 42, "text": "React\n22 Kontrolowane vs \nniekontrolowane komponenty?"}, {"page_number": 43, "text": "Komponentem kontrolowanym  jest komponent reprezentu -\nj\u0105cy pole formularza ( <select> , <textarea> , <input> , itp.), \nkt\u00f3rego warto\u015bci\u0105 zarz\u0105dza React. \nGdy u\u017cytkownik wprowadzi do niego dane, wywo\u0142ywana \njest obs\u0142uga zdarzenia, podczas kt\u00f3rej nast\u0119puje decyzja czy warto\u015b\u0107 jest poprawna i mo\u017cna komponent ponownie rende -\nrowa\u0107. \nZ kolej komponent niekontrolowany dzia\u0142a tak, jak wszystkie \npola formularza istniej\u0105ce poza Reactem. Gdy u\u017cytkownik \nwprowadzi do niego dane, zmiana warto\u015bci nast\u0119puje automa -\ntycznie, bez konieczno\u015bci obs\u0142ugiwania tego w kodzie Reacta.\nInnymi s\u0142owy komponent niekontrolowany traktuje DOM jako \nsource of truth warto\u015bci p\u00f3l formularza, a komponent kontrolo -\nwany korzysta ze swojego wewn\u0119trznego stanu."}, {"page_number": 44, "text": "React\n23 Czym s\u0105 \nkomponenty wy\u017cszego rz\u0119du?"}, {"page_number": 45, "text": "Komponent wy\u017cszego rz\u0119du (HOC) to funkcja, kt\u00f3ra przyjmu -\nje jako argument inny komponent i zwraca nowy komponent.\nTak jak zwyk\u0142y komponent przekszta\u0142ca props na element na \nstronie, tak komponent wy\u017cszego rz\u0119du przekszta\u0142ca kompo-\nnent w inny komponent .\nCo wa\u017cne nie modyfikuje  przekazanego mu komponentu ani \nnie stosuje dziedziczenia w celu skopiowania jego zachowania. \nZamiast tego wkomponowuje przekazany komponent poprzez jego opakowanie w kontener. \nKomponent wy\u017cszego rz\u0119du jest zatem czyst\u0105 funkcj\u0105 (ang. \npure function), nie maj\u0105c\u0105 \u017cadnych efekt\u00f3w ubocznych. \nU\u0142atwia to re-u\u017cycie kodu, logiki i abstrakcji wyst\u0119puj\u0105cych w kodzie i jest dobrym sposobem na wydzielenie wsp\u00f3lnych odpowiedzialno\u015bci  do jednego sp\u00f3jnego komponentu. "}, {"page_number": 46, "text": "React\n24 Do czego s\u0142u\u017cy \nReact.memo()?"}, {"page_number": 47, "text": "React.memo()  jest funkcj\u0105 tworz\u0105c\u0105 komponenty wy\u017cszego \nrz\u0119du, kt\u00f3re pozwalaj\u0105 na optymalizacj\u0119 wydajno\u015bci aplikacji \npoprzez zapobiegaj\u0105 zbyt cz\u0119stemu renderowaniu komponen -\nt\u00f3w funkcyjnych.\nKomponent mo\u017cna opakowa\u0107 w React.memo()  w celu popra -\nwy wydajno\u015bci, je\u015bli przy takich samych props  renderuje ten \nsam widok i t\u0105 sam\u0105 struktur\u0119. Je\u015bli komponent u\u017cywa hook\u00f3w \nuseState()  lub useContext() , nadal b\u0119dzie aktualizowa\u0142 si\u0119 \nprzy zmianie stanu komponentu lub kontekstu.\nDomy\u015blnie, komponent wykona jedynie p\u0142ytkie (ang. shallow) \npor\u00f3wnanie obiekt\u00f3w przekazanych we w\u0142a\u015bciwo\u015bciach. \nconst Tweet = React .memo(function  Tweet( props) {\n    // ...\n});"}, {"page_number": 48, "text": "React\n25 Czym jest \nPureComponent?"}, {"page_number": 49, "text": "React.PureComponent  jest to klasa zbli\u017cona do  \nReact.Component , z t\u0105 r\u00f3\u017cnic\u0105, \u017ce metoda cyklu \u017cycia  \nshouldComponentUpdate()  jest w niej obs\u0142ugiwana auto -\nmatycznie i wykonuje por\u00f3wnanie obiekt\u00f3w props  i state  \nz u\u017cyciem p\u0142ytkiego (ang. shallow) por\u00f3wnania. \nDzi\u0119ki temu mo\u017cna zapobiec zbyt cz\u0119stemu renderowaniu \nkomponent\u00f3w. W przypadku React.Component  takie po-\nr\u00f3wnanie trzeba napisa\u0107 samemu. Nale\u017cy jednak pami\u0119ta\u0107, \u017ce \npor\u00f3wnywanie obiekt\u00f3w mo\u017ce r\u00f3wnie\u017c okaza\u0107 si\u0119 kosztowne, \nwi\u0119c korzystanie z PureComponent  powinno by\u0107 przemy\u015blane.\nJe\u015bli metoda render()  komponentu wy\u015bwietla ten sam rezul -\ntat przy tych samych props  i state , mo\u017cna przekszta\u0142ci\u0107 go \nna React.PureComponent , aby poprawi\u0107 wydajno\u015b\u0107. "}, {"page_number": 50, "text": "React\n26 Czym s\u0105 granice \nb\u0142\u0119d\u00f3w?"}, {"page_number": 51, "text": "Granice b\u0142\u0119d\u00f3w (ang. error boundary) to komponenty, kt\u00f3re \nprzechwytuj\u0105 b\u0142\u0119dy wyst\u0119puj\u0105ce wewn\u0105trz drzewa komponen -\nt\u00f3w, a nast\u0119pnie loguj\u0105 je i wy\u015bwietlaj\u0105 zast\u0119pczy interfejs UI, \nzamiast pokazywa\u0107 ten niepoprawnie dzia\u0142aj\u0105cy. \nAby komponent klasowy sta\u0142 si\u0119 granic\u0105 b\u0142\u0119du, musi definio -\nwa\u0107 jedn\u0105, lub obie z poni\u017cszych metod cyklu \u017cycia: \n\u2022 static getDerivedStateFromError()  do wyrende -\nrowania zast\u0119pczego UI po rzuceniu b\u0142\u0119du \n\u2022 componentDidCatch()  do zalogowania informacji \no b\u0142\u0119dzie.\nGranice b\u0142\u0119d\u00f3w nie obs\u0142uguj\u0105 b\u0142\u0119d\u00f3w w: procedurach obs\u0142ugi \nzdarze\u0144 (ang. event handlers), asynchronicznym kodzie, kom -\nponentach renderowanych po stronie serwera oraz b\u0142\u0119d\u00f3w rzuconych w ramach  dzia\u0142ania samego error boundary."}, {"page_number": 52, "text": "React\n27 Jakie znasz \nmetody cyklu \u017cycia komponentu?"}, {"page_number": 53, "text": "\u2022 getDerivedStateFromProps : wywo\u0142ywana tu\u017c przed ka\u017c -\ndym wywo\u0142aniem render() ; Powinna zwr\u00f3ci\u0107 obiekt, aby \nzaktualizowa\u0107 stan, lub zwr\u00f3ci\u0107 null, aby nie aktualizowa\u0107.\n\u2022 componentDidMount : wywo\u0142ywana po pierwszym rendero -\nwaniu; jest miejscem gdzie mo\u017cna umie\u015bci\u0107 obs\u0142ug\u0119 \u017c\u0105da\u0144 \nHTTP, event listenery lub inicjalizacj\u0119 wymagaj\u0105c\u0105 DOM\n\u2022 shouldComponentUpdate : okre\u015bla, czy komponent zostanie \nzaktualizowany (domy\u015blnie tak).\n\u2022 getSnapshotBeforeUpdate : wywo\u0142ywana tu\u017c przed zapisa -\nniem zmian w DOM.\n\u2022 componentDidUpdate : obs\u0142uguje zmiany w DOM w odpo -\nwiedzi na zmiany w props lub state.\n\u2022 componentWillUnmount : wywo\u0142ywana tu\u017c przed usuni\u0119 -\nciem komponentu; jest miejscem, gdzie mo\u017cna anulowa\u0107 \u017c\u0105dania HTTP oraz usun\u0105\u0107 event listenery."}, {"page_number": 54, "text": "React\n28 Jak wykona\u0107 akcj\u0119 \ntylko raz - podczas renderowania?"}, {"page_number": 55, "text": "Aby wykona\u0107 akcj\u0119 tylko raz podczas pierwszego renderowa -\nnia, mo\u017cna skorzysta\u0107:\nw przypadku komponent\u00f3w klasowych - z metody cyklu \u017cycia \nkomponentu componentDidMount() :\nw przypadku komponent\u00f3w funkcyjnych - z hooka useEffect  \nprzekazuj\u0105c dodatkowo pust\u0105 tablic\u0119 [] jako drugi parametr:componentDidMount () {\n    trackPageView ('Homepage ');\n}\nuseEffect (() => {\n    trackPageView ('Homepage ');\n}, []);"}, {"page_number": 56, "text": "React\n29 Metoda setState() \njest synchroniczna czy asynchroniczna?"}, {"page_number": 57, "text": "Metoda setState()  dzia\u0142a asynchronicznie a jej wywo\u0142ania s\u0105 \ngrupowane ze wzgl\u0119d\u00f3w wydajno\u015bciowych.\nDzi\u0119ki temu, je\u015bli zar\u00f3wno parent component, jak i child com-\nponent wywo\u0142aj\u0105 setState()  podczas zdarzenia, komponent \ndziecko nie zostanie wyrenderowany dwukrotnie. Zamiast \ntego React uruchomi wszystkie te aktualizacje stanu na koniec obs\u0142ugi zdarzenia.\nReact celowo czeka, a\u017c wszystkie komponenty wywo\u0142aj\u0105 \nsetState()  w swoich procedurach obs\u0142ugi zdarze\u0144, zanim \nzacznie ponownie renderowa\u0107 drzewo komponent\u00f3w. Dzi\u0119ki temu unikamy niepotrzebnego i kosztownego  wielo-\nkrotnego renderowania, co znacz\u0105co wp\u0142ywa to na wydajno\u015b\u0107."}, {"page_number": 58, "text": "React\n30 Dlaczego nie nale\u017cy \nwprost zmienia\u0107 warto\u015bci this.state?"}, {"page_number": 59, "text": "Gdyby aktualizowa\u0107 bezpo\u015brednio obiekt this.state  we-\nwn\u0105trz komponentu, React  nie mia\u0142by mo\u017cliwo\u015bci rozpozna\u0107 \nkiedy nale\u017cy taki komponent ponownie renderowa\u0107.\nKorzystanie z setState()  zapewnia nam tak\u0105 mo\u017cliwo\u015b\u0107. \nSama operacja aktualizacji stanu jest asynchroniczna , dzi\u0119ki \nczemu React mo\u017ce j\u0105 optymalizowa\u0107.Jedynym miejscem, w kt\u00f3rym mo\u017cna przypisywa\u0107 this.state  \nbezpo\u015brednio, jest konstruktor komponentu.\nAby zaktualizowa\u0107 stan w oparciu o poprzednie jego warto\u015bci, \nmo\u017cna dodatkowo przekaza\u0107 do setState()  funkcj\u0119, kt\u00f3ra \nprzyjmuje state i props jako parametry:\nthis.setState ((state, props) => ({\n    count : state.count + props.increment\n}));"}, {"page_number": 60, "text": "React\n31 Jaka jest rola funkcji \nprzekazywanej do setState()?"}, {"page_number": 61, "text": "Funkcja przekazywana jako parametr do setState()  zamiast \nobiektu pozwala na aktualizacj\u0119 stanu komponentu w oparciu \no poprzedni stan  oraz warto\u015b\u0107 props. \nSama aktualizacja stanu jest asynchroniczna,  co pozwala Reac-\ntowi grupowa\u0107 tego typu operacje i je optymalizowa\u0107. \nStan mo\u017ce nie zosta\u0107 zaktualizowany natychmiast po wywo\u0142a -\nniu setState() , co ma znaczenie, je\u015bli wywo\u0142ujemy t\u0105 metod\u0119 \nwielokrotnie, np:\nthis.setState ({ count : this.state.count + 1 })\nthis.setState ({ count : this.state.count + 1 })\n// po wykonaniu nadal state.count === 1\n//\u00a0aby\u00a0pozby\u0107\u00a0si\u0119\u00a0b\u0142\u0119du,\u00a0nale\u017cy\u00a0skorzysta\u0107\u00a0z:this.setState ((state, props) => ({\n    count : state.count + props.increment\n}));"}, {"page_number": 62, "text": "React\n32 Jaka jest r\u00f3\u017cnica \nmi\u0119dzy zdarzeniami w React i w HTML?"}, {"page_number": 63, "text": "W React zdarzenia s\u0105 podobne do natywnych zdarze\u0144 prze -\ngl\u0105darki, takich jak mouse hover, mouse click, key press. Istnieje \njednak kilka r\u00f3\u017cnic:\n\u2022 Zdarzenia Reacta zapisywane s\u0105 jako camelCase , a nie \njako lowercase .\n\u2022 W przeciwie\u0144stwie do zdarze\u0144 HTML nie mog\u0105 zwraca\u0107 \nfalse w celu przerwania obs\u0142ugi, tylko musz\u0105 wywo\u0142ywa\u0107 \npreventDefault() .\n\u2022 W JSX procedura obs\u0142ugi zdarzenia przekazywana jest \njako funkcja, a nie \u0142a\u0144cuch znak\u00f3w, jak w przypadku zdarze\u0144 HTML. \n\u2022 Wywo\u0142anie funkcji obs\u0142uguj\u0105cej zdarzenie w React nie \nmusi si\u0119 ko\u0144czy\u0107 nawiasami ().\n<button onClick ={handleClick }>Click me!</ button>"}, {"page_number": 64, "text": "React\n33 Czym jest \nSyntheticEvent?"}, {"page_number": 65, "text": "SyntheticEvent  (zdarzenie syntetyczne) jest to obiekt opako -\nwuj\u0105cy zdarzenie, b\u0119d\u0105cy jednocze\u015bnie cz\u0119\u015bci\u0105 systemu obs\u0142u -\ngi zdarze\u0144 Reacta. Zapewnia jednolity interfejs obs\u0142ugi zdarze\u0144 \nniezale\u017cnie od stosowanej przegl\u0105darki.\nZdarzenia syntetyczne posiadaj\u0105 taki sam interfejs jak natywne \nzdarzenia, wliczaj\u0105c w to metody stopPropagation()  oraz \npreventDefault()  i gwarantuj\u0105 identyczne dzia\u0142anie na \nwszystkich przegl\u0105darkach.\nAby skorzysta\u0107 z opakowanego, natywnego zdarzenia, nale\u017cy \nodwo\u0142a\u0107 si\u0119 do niego poprzez w\u0142a\u015bciwo\u015b\u0107 nativeEvent . \nNa przyk\u0142ad, w zdarzeniu onMouseLeave  warto\u015b\u0107  \nevent.nativeEvent  b\u0119dzie wskazywa\u0142o na natywne zdarze -\nnie mouseout  z API przegl\u0105darki."}, {"page_number": 66, "text": "React\n34 Jakie znaczenie \nmaj\u0105 klucze w React?"}, {"page_number": 67, "text": "Klucze  pomagaj\u0105 Reactowi zidentyfikowa\u0107 elementy kolekcji, \nkt\u00f3re uleg\u0142y zmianie, zosta\u0142y dodane lub usuni\u0119te. S\u0105 wyko -\nrzystywane do rozr\u00f3\u017cniania element\u00f3w wirtualnego modelu \nDOM. Dzi\u0119ki kluczom React mo\u017ce zoptymalizowa\u0107 rendero-wanie poprzez u\u017cycie istniej\u0105cych ju\u017c element\u00f3w.\nNajlepszym sposobem wyboru klucza jest u\u017cycie unikatowego ci\u0105gu znak\u00f3w, kt\u00f3ry jednoznacznie identyfikuje dany element.\nKlucze nie musz\u0105 by\u0107 unikalne globalnie  - wystarczy, \u017ce s\u0105 \nunikalne w kontek\u015bcie w kt\u00f3rym s\u0105 u\u017cyte. Mo\u017cna tych samych \nkluczy u\u017cy\u0107 do renderowania element\u00f3w w r\u00f3\u017cnych listach.\nconst todoItems  = Todos. map((todo) =>\n    <li key={todo.id}>\n        {todo.text}\n    </li>\n);"}, {"page_number": 68, "text": "React\n35 Jakie znaczenie \nmaj\u0105 refs w React?"}, {"page_number": 69, "text": "Referencje ref to specjalny atrybut wspierany przez React, \nkt\u00f3ry zapewnia dost\u0119p do API element\u00f3w modelu DOM lub \nelement\u00f3w stworzonych przez wywo\u0142anie render() . \nMo\u017ce on by\u0107 funkcj\u0105, lub obiektem utworzonym przy u\u017cyciu React.createRef() . Zazwyczaj jest tworzony w konstrukto -\nrze i od razu przypisywany do instancji komponentu. Podczas odczytu w\u0119ze\u0142 DOM jest dost\u0119pny przez atrybut current :\n//\u00a0utworzenie\u00a0ref\u00a0i\u00a0przypisanie\u00a0w\u00a0konstruktorze\nthis.todosRef = React.createRef ();\n//\u00a0u\u017cycie\u00a0ref\u00a0w\u00a0komponencie<div ref={this.todosRef } />\n//\u00a0dost\u0119p\u00a0do\u00a0elementu\u00a0przez\u00a0atrybut\u00a0currentconst todos = this.todosRef. current;"}, {"page_number": 70, "text": "React\n36 Do czego s\u0142u\u017cy \nReact Router?"}, {"page_number": 71, "text": "React Router to biblioteka Reacta, kt\u00f3ra pozwala na dodawa -\nnie nowych ekran\u00f3w oraz nawigowanie mi\u0119dzy nimi. Posiada \nwiele zalet u\u0142atwiaj\u0105cych pisanie kodu, przyk\u0142adowo:\n\u2022 Posiada proste API, za pomoc\u0105 kt\u00f3rego u\u017cytkownik de -\nfiniuje i konfiguruje router podaj\u0105c \u015bcie\u017cki do poszcze -\ng\u00f3lnych ekran\u00f3w.\n\u2022 Opakowuje dost\u0119p do obiektu window.history , b\u0119d\u0105 -\ncego cz\u0119\u015bci\u0105 History API z HTML5. \n\u2022 Umo\u017cliwia konfiguracj\u0119 pod postaci\u0105 zwyk\u0142ego kompo -\nnentu Reacta <BrowserRouter> , w kt\u00f3rym definiujemy \n\u015bcie\u017cki - <Route> .\n\u2022 Jest podzielona na trzy cz\u0119\u015bci: Web, Native oraz cz\u0119\u015b\u0107 \nwsp\u00f3ln\u0105 Core , co u\u0142atwia pisanie kodu na r\u00f3\u017cne \u015brodo -\nwiska. "}, {"page_number": 72, "text": "React\n37 Jakie znasz typy \nkomponent\u00f3w <Router>?"}, {"page_number": 73, "text": "React Router posiada kilka implementacji Routera, z kt\u00f3rych \nmo\u017cna korzysta\u0107 w zale\u017cno\u015bci od potrzeb i \u015brodowiska:\n<Router>  - Podstawowa, niskopoziomowa implementacja \nbazowa dla wszystkich konkretnych implementacji router\u00f3w.\n<BrowserRouter>  - U\u017cywa History API z HTML5 do nawigacji \ni utrzymywania adresu URL sp\u00f3jnego ze stanem aplikacji.<HashRouter>  - Do nawigacji u\u017cywa tylko cz\u0119\u015bci hash \nz adresu URL - dost\u0119pnego przez window.location.hash  - \nprzyk\u0142adowo #/users/guest .\n<MemoryRouter>  - Przechowuje informacje o URL i jego \nzmianach w pami\u0119ci; nie modyfikuje przy tym adresu strony \nw pasku adresu przegl\u0105darki, co jest szczeg\u00f3lnie przydatne przy testowaniu w React Native."}, {"page_number": 74, "text": "React\n38 Co r\u00f3\u017cni \n<BrowserRouter> i <HashRouter>?"}, {"page_number": 75, "text": "Zar\u00f3wno <BrowserRouter>  oraz <HashRouter>  to dwie naj -\nwa\u017cniejsze implementacje komponentu routera w aplikacjach \nwebowych. \nR\u00f3\u017cni\u0105 si\u0119 g\u0142\u00f3wnie sposobem w jaki przechowuj\u0105 informacje \no URL i komunikuj\u0105 si\u0119 z serwerem.\n<BrowserRouter>  korzysta z pe\u0142nej \u015bcie\u017cki URL, co jest naj -\nbardziej czytelnym rozwi\u0105zaniem, jednak wymaga konfiguracji \npo stronie serwera, aby ten zwraca\u0142 t\u0105 sam\u0105 stron\u0119 HTML niezale\u017cnie od \u015bcie\u017cki przekazanej w \u017c\u0105daniu HTTP.\n<HashRouter>  przechowuje informacje o lokalizacji strony \nw cz\u0119\u015bci hash adresu URL, przyk\u0142adowo #/users/admin . \nZgodnie ze specyfikacj\u0105 Location API, zmiana hash nie powo -\nduje przekierowania, wi\u0119c komunikacja z serwerem nie jest \nwymagana. "}, {"page_number": 76, "text": "React\n39 Jak wywo\u0142a\u0107 routing \nprogramistycznie?"}, {"page_number": 77, "text": "Aby programistycznie wywo\u0142a\u0107 routing i przekierowa\u0107 u\u017cyt -\nkownika na inny ekran mo\u017cna skorzysta\u0107 z dw\u00f3ch rozwi\u0105za\u0144:\n\u2022 Wykorzysta\u0107 hook useHistory()  w komponentach \nfunkcyjnych, kt\u00f3ry daje dost\u0119p do obiektu history i jego \nmetod pushState()  oraz replaceState() : \n \n\u2022 Skorzysta\u0107 z funkcji tworz\u0105cej komponenty wy\u017cszego \nrz\u0119du withRouter() , kt\u00f3ra udost\u0119pnia informacje \no obiekcie history komponentowi, kt\u00f3ry opakowuje:let history = useHistory ();\nconst Goto = withRouter (({ history }) => (\n  <button type='button '\n    onClick={() => {history .push('/abc')}}>\n      Click Me!\n  </button>\n))"}, {"page_number": 78, "text": "React\n40 Jak obs\u0142u\u017cy\u0107 brak \nstrony (status 404) w React Router?"}, {"page_number": 79, "text": "Nale\u017cy w tym celu skorzysta\u0107 z komponentu <Switch> . Jego \ndzia\u0142anie polega na renderowaniu pierwszego elementu \n<Route> , kt\u00f3rego path  pokrywa si\u0119 z wyszukiwanym adresem. \nOstatni <Route>  mo\u017ce by\u0107 wykorzystany do wy\u0142apywania \nwszystkich niezdefiniowanych przypadk\u00f3w. W tym celu mo\u017cna pomin\u0105\u0107 path , lub zdefiniowa\u0107 path  pasuj\u0105cy do wszystkich \nprzypadk\u00f3w, na przyk\u0142ad path=\"*\" .\n<Switch>\n    < Route exact path=\"/\">\n        < Home />\n    </ Route>\n    < Route path=\"*\">\n        < NotFound  />\n    </ Route>\n</Switch >"}, {"page_number": 80, "text": "React\n41 Jak obs\u0142u\u017cy\u0107 \nprzekierowanie w React Router?"}, {"page_number": 81, "text": "Przekierowanie w React Router mo\u017cna zrealizowa\u0107 za pomoc\u0105 \nkomponentu <Redirect> . Przekierowanie na nowy adres \nnast\u0105pi w momencie renderowania. \nPodobnie, jak w przypadku przekierowania realizowanego \npo stronie serwera - czyli HTTP 3xx, nast\u0105pi zmiana adresu \nw pasku adresu przegl\u0105darki i zostanie dodany nowy wpis do historii przegl\u0105dania. \n<Route exact path=\"/\">\n    {\n loggedIn  \n             ? <Redirect  to=\"/dashboard \" /> \n            : <PublicHomePage  />\n    }\n</Route>"}, {"page_number": 82, "text": "React\n42 Jak podzieli\u0107 kod na \npodstawie \u015bcie\u017cki URL?"}, {"page_number": 83, "text": "Podzia\u0142 kodu na podstawie URL mo\u017cna zrealizowa\u0107 za pomoc\u0105 \nfunkcji React.lazy , kt\u00f3ra pozwala renderowa\u0107 dynamicznie \nimportowane komponenty tak samo jak wszystkie inne. \n\u201cLeniwy\u201d komponent powinien zosta\u0107 wyrenderowany we -\nwn\u0105trz elementu <Suspense> , kt\u00f3ry pozwala na wy\u015bwietlenie \nkomunikatu na czas \u0142adowania, np. informacji o post\u0119pie:\nconst UserList  = React .lazy(\n  () => import ('./UserList ')\n);\nfunction  DashboardComponent () {\n  return  (\n    < Suspense  fallback ={<div>Loading...</ div>}>\n      < UserList  />\n    </ Suspense >\n  );}"}, {"page_number": 84, "text": "React\n43 Czym jest Redux?"}, {"page_number": 85, "text": "Redux to otwarta biblioteka do zarz\u0105dzania stanem aplikacji. \nOpiera si\u0119 na nast\u0119puj\u0105cych za\u0142o\u017ceniach:\n\u2022 Single source of truth - stan ca\u0142ej aplikacji jest przecho -\nwywany jako drzewo obiekt\u00f3w w jednym, centralnym miejscu, kt\u00f3rym jest store.\n\u2022 Obiekt stanu jest tylko do odczytu  - jedynym sposobem \nna jego modyfikowanie jest wykorzystanie akcji. Akcje to obiekty opisuj\u0105ce zmian\u0119 stanu. Dzi\u0119ki temu mamy pewno\u015b\u0107, \u017ce stan nie zostanie zmieniony w niekontrolo -\nwany spos\u00f3b.\n\u2022 Zmiany stanu nast\u0119puj\u0105 przez reduktory (ang. reducers), \nkt\u00f3re okre\u015blaj\u0105 jak zmienia si\u0119 stan pod wp\u0142ywem akcji. S\u0105 to funkcje nie posiadaj\u0105ce efekt\u00f3w ubocznych, kt\u00f3re przyjmuj\u0105 jako parametr bie\u017c\u0105cy stan oraz akcj\u0119 i zwra -\ncaj\u0105 nowy stan aplikacji."}, {"page_number": 86, "text": "React\n44 Jakie znasz \nkomponenty Redux?"}, {"page_number": 87, "text": "Redux sk\u0142ada si\u0119 z nast\u0119puj\u0105cych komponent\u00f3w: \n\u2022 Akcje (ang. actions) - obiekty reprezentuj\u0105ce CO zmie-\nni\u0142o si\u0119 w stanie aplikacji. Posiadaj\u0105 informacj\u0119 o tym co \nsi\u0119 zmienia oraz dane reprezentuj\u0105ce zmian\u0119. Wysy\u0142ane \ns\u0105 przez wywo\u0142anie metody store.dispatch() . \n\u2022 Reduktory (ang. reducers) - funkcje opisuj\u0105ce JAK \ndane z akcji modyfikuj\u0105 stan aplikacji przechowywany \nwewn\u0105trz store.\n\u2022 Store - obiekt, kt\u00f3ry przechowuje stan aplikacji w po -\nstaci drzewa i pilnuje zmian stanu. Umo\u017cliwia r\u00f3wnie\u017c \nodczyt stanu przez metod\u0119 getState()  a tak\u017ce wys\u0142a -\nnie akcji za pomoc\u0105 metody dispatch() . Dodatkowo \nrejestruje listenery za pomoc\u0105 metody subscribe()  \noraz umo\u017cliwia ich wyrejestrowanie."}, {"page_number": 88, "text": "React\n45 Jakie s\u0105 korzy\u015bci \nz zastosowania Redux?"}, {"page_number": 89, "text": "\u2022 Czytelny, zrozumia\u0142y i \u0142atwy w utrzymaniu kod; aktu -\nalizacja stanu odbywa si\u0119 zawsze w ten sam spos\u00f3b, za \npomoc\u0105 akcji i reduktor\u00f3w.\n\u2022 Jasna struktura aplikacji i podzia\u0142 kodu u\u0142atwiaj\u0105ce \nprac\u0119 w du\u017cych zespo\u0142ach.\n\u2022 \u0141atwa integracja z server-side rendering . \n\u2022 Dost\u0119p do narz\u0119dzi programistycznych u\u0142atwiaj\u0105cych \u015bledzenie zmian stanu  aplikacji w jednym, centralnie \nzarz\u0105dzanym miejscu.\n\u2022 Mo\u017cliwo\u015b\u0107 odtworzenia stanu aplikacji z dowolnego \nmomentu w przesz\u0142o\u015bci dzi\u0119ki zastosowaniu funkcji bez efekt\u00f3w ubocznych.\n\u2022 \u0141atwe testowanie dzia\u0142ania akcji, store i reduktor\u00f3w, \nkt\u00f3re s\u0105 zwyk\u0142ymi funkcjami, dobrze izolowanymi od reszty aplikacji i nie posiadaj\u0105cymi efekt\u00f3w ubocznych.\n\u2022 Du\u017ca i aktywna spo\u0142eczno\u015b\u0107 ."}, {"page_number": 90, "text": "React\n46 Do czego s\u0142u\u017cy \nRedux Thunk?"}, {"page_number": 91, "text": "Redux Thunk dostarcza middleware pozwalaj\u0105cy na tworzenie \nfunkcji, kt\u00f3rych zadaniem jest wykonanie asynchronicznej \noperacji a nast\u0119pnie odczytanie stanu i wys\u0142anie akcji. \nRealizuje si\u0119 to poprzez tzw. action creators. Dzi\u0119ki nim Thunk \nop\u00f3\u017ania wys\u0142anie akcji do momentu kiedy zostanie zrealizowa -\nna operacja asynchroniczna, np. \u017c\u0105danie do REST API. \nWewn\u0119trzna funkcja - thunk  - przyjmuje jako parametry meto -\ndy dispatch()  oraz getState() , przyk\u0142adowo:\nfunction  updateUserRole (role) {\n  return  dispatch  => fetchUsers ().then(\n    users => dispatch (changeRoleTo (role, users)),\n    error => dispatch (apologize ('Failed' , error))\n  );\n}store.dispatch (updateUserRole ('support '));"}, {"page_number": 92, "text": "React\n47 Do czego s\u0142u\u017cy \nRedux Saga?"}, {"page_number": 93, "text": "Redux Saga to (podobnie do redux-thunk ) middleware do \nobs\u0142ugi efekt\u00f3w ubocznych. R\u00f3\u017cnica polega jednak na tym, \u017ce \njest zbudowana wok\u00f3\u0142 generator\u00f3w z ES6. \nDzi\u0119ki temu kod nie musi wykorzystywa\u0107 callback\u00f3w a wyko -\nnanie operacji asynchronicznej jest r\u00f3wnie proste jak realizacja \nakcji synchronicznej. Poprawia przy tym czytelno\u015b\u0107 kodu, obs\u0142ug\u0119 wyj\u0105tk\u00f3w oraz u\u0142atwia testowanie.\n`\n//\u00a0Saga\u00a0fetchUser\u00a0czeka\u00a0na\u00a0wywo\u0142anie\u00a0akcji\u00a0USER_REQUESTED\n//\u00a0np.\u00a0dispatch({\u00a0type:\u00a0'USER_REQUESTED',\u00a0payload:\u00a0{\u00a0userId\u00a0}\u00a0})function*  fetchUser (action) {\n  const user = yield  call(Api.fetchUser, action.payload.userId);\n  yield put({ type: \"USER_SUCCEEDED \", user: user });\n}\n//\u00a0Wywo\u0142uje\u00a0fetchUser\u00a0dla\u00a0ka\u017cdej\u00a0akcji\u00a0tego\u00a0typu\nfunction*  mySaga() {\n    yield takeEvery (\"USER_REQUESTED \", fetchUser );\n}"}, {"page_number": 94, "text": "React\n48 Presentational \nvs Container Components?"}, {"page_number": 95, "text": "Presentational Component  \n(a.k.a Dumb Component)Container Component  \n(a.k.a Smart Component)\nOdpowiada za to jak dane \nwygl\u0105daj\u0105 na ekranieOdpowiada za to jak dzia\u0142a logika wy\u015bwietlania\nKorzysta z danych i callbac -\nk\u00f3w pochodz\u0105cych z propsOdczytuje dane z Redux store i tworzy akcje\nNie ma zale\u017cno\u015bci do reszty aplikacjiPosiada wiedz\u0119 i korzysta z Redux\nNie posiada w\u0142asnego stanu (lub posiada tylko stan UI)Posiada stan wewn\u0119trzny\nCz\u0119sto implementowane jako komponenty funkcyjne\nCz\u0119sto generowane np. \nprzez funkcj\u0119 connect()\nPrzyk\u0142ad: UserInfo, Sidebar Przyk\u0142ad: FilteredStoryList"}, {"page_number": 96, "text": "React\n49 Do czego s\u0142u\u017cy \nkomponent  StrictMode?"}, {"page_number": 97, "text": "Komponent <StrictMode />  jest narz\u0119dziem pozwalaj\u0105cym \nna znalezienie w trybie deweloperskim potencjalnych proble -\nm\u00f3w w aplikacji. \nNie renderuje \u017cadnego widocznego UI, ale aktywuje dodat -\nkowe ostrze\u017cenia wy\u015bwietlaj\u0105ce informacje o problemach \nw konsoli, dotycz\u0105ce np:\n\u2022 U\u017cycia niebezpiecznych metod cyklu \u017cycia komponentu.\n\u2022 U\u017cycia przestarza\u0142ego API, np. tekstowych refs.\n\u2022 Wykrycia nieoczekiwanych efekt\u00f3w ubocznych\n\u2022 Wykorzystania przestarza\u0142ego API kontekst\u00f3w\n<React.StrictMode >\n  <div>\n    < Sidebar />\n  </div>\n</React.StrictMode >"}, {"page_number": 98, "text": "React\n50 Co zrobisz je\u015bli \naplikacja renderuje si\u0119 zbyt wolno?"}, {"page_number": 99, "text": "Nale\u017cy rozpocz\u0105\u0107 od sprawdzenia Profilera  dost\u0119pnego w ra -\nmach React Dev Tools. Na podstawie danych mo\u017cna znale\u017a\u0107 \nkomponenty, kt\u00f3re renderuj\u0105 si\u0119 zbyt d\u0142ugo, lub zbyt cz\u0119sto.\nJednym z najcz\u0119stszych problem\u00f3w jest ponowne renderowa -\nnie komponentu, gdy nie jest to wymagane. React dostarcza narz\u0119dzia pozwalaj\u0105ce rozwi\u0105za\u0107 ten problem:\nReact.memo() , kt\u00f3re zapobiega renderowaniu komponent\u00f3w \nfunkcyjnych, orazReact.PureComponent , kt\u00f3ry zapobiega renderowaniu kom -\nponent\u00f3w klasowych.\nOba te rozwi\u0105zania bazuj\u0105 na p\u0142ytkim (ang. shallow) por\u00f3w -\nnywaniu obiekt\u00f3w state i prop, co r\u00f3wnie\u017c mo\u017ce okaza\u0107 si\u0119 \nkosztowne. Nale\u017cy z nich korzysta\u0107 w przemy\u015blany spos\u00f3b.\nCOPYRIGHT \u00a9 2020 fiszkijs.pl"}]